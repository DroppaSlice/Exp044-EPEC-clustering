---
title: "Exp044"
output: html_notebook
---
## Project Introduction

The overall goal of this project (Exp044) is to use clustering analysis to examine the similarities and differences between the distribution of Pas sRNA genes and EPEC virulence genes across 70 EPEC isolates. The theory is that if we treat the presence or absence of a gene in a specific isolate as a variable, then we can calculate a dissimilarity matrix using a presence absence matrix of all of the genes. Then, genes that are similarly distributed across the isolates will have low dissimilarity scores and cluster together. This will then give us a sense of whether any EPEC virulence genes are correlated with the presence of a Pas gene in a specific isolate genome. Similar distributions of sRNAs and virulence genes could indicate a genetic linkage that could come from shared horizontal or vertical evolution patterns. 

## Exp044-1: BLAST search for virulence genes across 

In this first section, I call a python script that I wrote called '01-blast_to_table.py'. The script is saved in the 'src' subdirectory and the usage is documented within the code. The code essentially just calls blastn to run a blast nucleotide search based on specified inputs for the query and target sequences and then returns the results in a tab delimited text file based on outformat 6 with 12 columns. 

```{bash}
python3 src/01-blast_to_table.py inputs/Exp044_query.fasta inputs/hazen_db/Hazen2016 outputs/Exp044_blastResults.txt 0.0001
```

From the input above, we can see that our inputs are both stored in the 'inputs' sub-directory of the project directory. The query for this search is a fasta file 'EPEC_effectors.fasta' that contain the nucleotide sequences of various effectors 


## Exp044-2: Parsing and cleaning BLAST results data

In this second chunk, we use an R script to parse and re-shape our blast results table into a presence absence table. The output is actually in a nice format for manipulation and can be summarized easily with table(). In this seciton, I include 2 functions:

* **read.blast()** - is a new function that takes a standard blast outformat 6 table and returns an R dataframe with named columns. The function takes one argument 'filepath' which should be a string pointing to the filepath of a tabular blast results file
* **make.pa.table()** - takes an R dataframe generated by read.blast() and returns a presence absence table. Takes up 4 arguments, df = data.frame object containing blast results, x and y should be strings that define the x and y axes respectively of the final table, and 'binary' is a boolean that if true will turn the final table into a binary table where the presence of any number of blast hits in an individual is indicated by 1

```{r 02-presence_absence_table.R}
library(stringr)
library(seqinr)
library(dplyr)

#-----Defining the read.blast function-----#
read.blast <- function(filepath){
  x <- read.table(file = filepath,
                  col.names = c("qseqid", "sseqid", "pident", "length", "mismatch", "gapopen", "qstart", "qend", "sstart", "send", "evalue", "bitscore"))
  return(x)
}

#----running read.blast() and then performing some string manipulation to create a new accession.no variable specific to this dataset ----#
vf_df <- read.blast(filepath = "outputs/Exp044_blastResults.txt") %>% 
  mutate(accession.no = str_sub(sseqid, 8, 11)) %>%
  mutate(accession.no = as.factor(accession.no)) %>%
  mutate(qseqid = as.factor(qseqid))

#-----checking the lengths of our accession.no and qseqid variables-----#
#the numbers should match the inputs (70 for accession.no), but the qseqid length may be different if some genes were not found at all
length(levels(vf_df$accession.no))
length(levels(vf_df$qseqid))

#-----defining a new function make.pa.table() that returns a presence absence table from the normalized blast ouput tabular format-----#
#Usage:
#make.pa.table() takes up to 4 arguments. df should be a df made from the blast tabular output. x and y should be strings that point to variable names inthe data frame df and will define the x and y axes respectively in the final table
#binary is a boolean value that if true (default) will convert the table into a binary presence absence table where any number of nonzero matches will be indicated by 1
make.pa.table <- function(df, x, y, binary = T){
 table <- table(df[[x]], df[[y]])
 if(binary == T){
   table <- (table >= 1) * 1
 }
}

#-----running make.pa.table() on Exp044 blast results-----#
vf_pa <- make.pa.table(vf_df, "accession.no", "qseqid")

#-----writing out our presence absence table to an intermediate file-----#
write.csv(vf_pa, file = "outputs/Exp044_presenceAbsence.csv")
```

## Exp044-3: Determining the appropriate cluster number

In this next code chunk, I am combining the virulence gene presence absence table with the Pas sRNA presence absence table that I generated in a previous project. The 'pas_presenceAbsence.csv' file is stored in the 'doc' subdirectory since it was generated separately from the code in this project. 

Next, this section re-shapes the combined presence absence table by inverting the data frame so that each gene is an observation and each isolate is considered a variable. This table is numerically scaled to a final scaled data frame ('scaled_df') that is stored as an intermediate file. Additionally in this section of code, I calculate and use a few different metrics to evaluate what the optimal number of clusters would be for an eventual clustering analysis. 

```{r 03-evaluate_clustering}
library(factoextra)
library(dplyr)
library(NbClust)
library(ggplot2)

#-----Reading in the two presence absence matrices that we made for the Pas genes and EPEC virulence genes-----#
#The two tables are then combined into a single data frame 'pa' that serves as the basis of our clustering analysis
vf_pa <- read.csv(file = "outputs/Exp044_presenceAbsence.csv") %>%
  rename(accession.no = X)
pas_pa <- read.csv(file = "doc/pas_presenceAbsence.csv")

#-----Reshaping the 'pa' dataframe-----#
#After reshaping, the pa dataframe should have only numerical values and the identifying accession number is stored as rownames
pa <- dplyr::left_join(pas_pa, vf_pa, by = "accession.no") %>%
  tibble::column_to_rownames("accession.no") %>%
  select(where(is.numeric))

#-----Scaling the dataframe into a numerical matrix-----#
scaled_df <- as.data.frame(na.omit(scale(t(pa))))
write.csv(x = scaled_df, file = "outputs/scaled_pa_table.csv")

#-----Plotting PCA to inspect clustering tendency-----#
fviz_pca_ind(prcomp(scaled_df), ggtheme = theme_bw()) 

#-----Running several clustering number optimization methods-----#
#Gap statistic
fviz_nbclust(scaled_df, kmeans, method="gap_stat")

#Silhouette method
fviz_nbclust(scaled_df, kmeans, method="silhouette")

#Calculating the Hopkins statistic
hopkins.res <- get_clust_tendency(data = scaled_df, n = 20)
hopkins.res$hopkins_stat
```

## Exp044-4: Clustering analysis and visualization

In this code chunk, I use the scaled data frame from the previous chunk to perform hierarchical k-means clustering of the EPEC virulence genes + sRNAs. In this section, I also define a new function:
* **plot.kmeans()** - generates an aesthetically consistent ggplot object using the fviz_cluster() function based on a specified number of clusters

```{r 04-hkmeans_clustering}
library(factoextra)
library(ggsci)

#-----Reading in scaled pa table from the chunk Exp044-3-----#
scaled_df <- read.csv(file = "outputs/scaled_pa_table.csv", row.names = 1)

#-----Defining function plot.kmeans()-----#
plot.kmeans <- function(data, nclust, title = "K-means clustering"){
  res <- hkmeans(data, k = nclust)
  plot <- fviz_cluster(res,
                       data = data,
                       ggtheme = theme_bw(),
                       ellipse = T,
                       repel = T,
                       shape = 16) +
    scale_color_nejm() +
    scale_fill_nejm() + 
    ggtitle(title)
  
  plot
}

#-----Plotting kmeans clusters based on two separate optimal cluster numbers, i.e. 4 and 7-----#
#Define a vector to iterate over with the cluster number
opt_clusters <- c(4,7)

#Initialize a list and iterator i to store the results
cluster.res <- list()
i <- 1

#Plot multiple cluster numbers using a for loop
for(n in opt_clusters){
  cluster.res[[i]] <- plot.kmeans(data = scaled_df,
                            nclust = n,
                            title = paste("K-means clustering with", n, "clusters"))
  cluster.res[[i+1]] <- hkmeans(x = scaled_df, k = n)
  i <- i + 2
}

#-----Returning list of cluster plots and saving clustering results-----#
cluster.res
write.csv(x = cluster.res[[2]]$cluster, file = "outputs/hkmeans_clustering_res_k4.csv")
write.csv(x = cluster.res[[4]]$cluster, file = "outputs/hkmeans_clustering_res_k7.csv")
```

